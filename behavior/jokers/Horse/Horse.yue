useful_things = assert(SMODS.load_file("useful_things.lua"))()
round = useful_things.round

required_horse_name_count = 40
horse_names = {
    "Chestnut"
    "Peanut"
    "Acorn"
    "Gertrude"
    "Slippy"
    "Crazy Horse"
    "Jimmy"
    "Potatoes"
    "Cupcake"  -- Keep this on an odd number so that Cupcake and Slayer are a pair :)
    "Slayer"
    "Lucky"
    "Special Week"
    "Mr. Felony"

    "Hemmingway"
    "Whiskey"
    "Chipschipschips"
    "Daisy"
    "Orchard"
    "Old Tom"
    "Sunrise"
    "Shepard"

    "Pumpernickel"

    "Bert"

    "Sprinkletoes"

    "Old ale"
    "Kettle Sour"

    "Clarence"
    "Spriggan"

    "Angel Face"
    "Casino"
    "Grasshopper"
    "Moscow Mule"
    "Rusty Nail"

    -- Stone fruit
    "Apricot"
    "Mulberry"
    "Pecan"
    "Walnut"
    "Hazelnut"
    "Cashew"
    "Butternut"
    "Macadamia"

    "Thimbleberry"

    -- Fruit
    "Currant"
    "Clementine"
    "Nectarine"
    "Dewberry"
}
bonus_types = {
    "chips"
    "luck"
    "money"
    "mult"
}

neigh = ->
    play_sound('hhj_neigh', 0.9 + math.random()*0.2, 1)

base_horse_joker = SMODS.Joker
    key: "horse_base"
    atlas: "atlas_horses"
    pos: atlas_horses_positions["base"]
    rarity: 1
    cost: 1
    update: (card, dt) =>
        if not card.area
            return
        if card.area.config.collection
            return
        new_horse = SMODS.create_card
            set: "Joker"
            area: G.jokers
            rarity: "hhj_horse"
            key_append: "horse"
        new_horse::add_to_deck()
        card.area::emplace(new_horse)
        new_horse::start_materialize()
        card::remove()

update_horse_negatives = ->
    -- print("um")
    -- for joker in *G.jokers.cards
    --     print(joker)
    --     joker::set_edition({negative: true}, true)
    owned = G.jokers and G.jokers.cards or {}
    shop = G.shop and G.shop_jokers.cards or {}

    owns_a_non_negative = false
    non_negative_index = nil
    for joker_index, owned_joker in ipairs(owned)
        if owned_joker.ability.is_horse and ((not owned_joker.edition) or (not (owned_joker.edition == "e_negative" or owned_joker.edition.negative)))
            owns_a_non_negative = true
            non_negative_index = joker_index
            break
    
    for joker_index, joker in ipairs({...owned, ...shop})
        unless joker.ability.is_horse
            continue
        if owns_a_non_negative and non_negative_index != joker_index
            joker::set_edition({negative: true}, true)
        else
            joker::set_edition({negative: false}, true)
            owns_a_non_negative = true


index = 0
for    bonus_1_index, bonus_1 in ipairs(bonus_types)                                                   do
 for   bonus_2_index, bonus_2 in ipairs([_ for _ in *bonus_types[bonus_1_index,                    ]]) do
  for  _,             bonus_3 in ipairs([_ for _ in *bonus_types[bonus_1_index + bonus_2_index - 1,]]) do 
    for _,             jack    in ipairs({false, true}                                                ) do 
        index += 1
        bonuses_as_list = {bonus_1, bonus_2, bonus_3}
        bonuses_for_this_horse = {
            chips:  round(8 / 1 * #[bonus for bonus in *bonuses_as_list when bonus == "chips"]) -- This *was* 8, 17, 25, and was going to become 10, 15, 25, but a plain 8*n was more consistent and close enough
            mult:   round(4 / 1 * #[bonus for bonus in *bonuses_as_list when bonus == "mult" ])
            money:  round(1 / 1 * #[bonus for bonus in *bonuses_as_list when bonus == "money"])
            luck:   round(1 / 1 * #[bonus for bonus in *bonuses_as_list when bonus == "luck" ])
        }
        
        horse_ability_description = {
            jack and "Per {C:attention}Jack{} scored:" or "Each {C:blue}Hand{} played:"
        }
        scale = "s:0.75"
        if bonuses_for_this_horse.chips > 0 then horse_ability_description[] = "{#{scale},C:chips}+#{           bonuses_for_this_horse.chips}{#{scale}} chips"
        if bonuses_for_this_horse.mult  > 0 then horse_ability_description[] = "{#{scale},C:mult}+#{            bonuses_for_this_horse.mult }{#{scale}} Mult"
        if bonuses_for_this_horse.money > 0 then horse_ability_description[] = "{#{scale},C:attention}#{        bonuses_for_this_horse.money}{#{scale},C:green} #1#/2{#{scale}} chance#{bonuses_for_this_horse.money>1 and 's' or ''} for {#{scale},C:money}$1{}"
        if bonuses_for_this_horse.luck  > 0 then horse_ability_description[] = "{#{scale},C:green}HORSE LUCK X#{bonuses_for_this_horse.luck }{#{scale}}"
        
        scale = "s:0.5"
        for line in *{
            "{#{scale},C:inactive}Additional {C:attention,#{scale}}Horses{#{scale},C:inactive} may appear, are {C:dark_edition,#{scale}}negative{#{scale}},"
            "{#{scale},C:inactive}and have varied abilities"

            -- "{C:attention}Horse Jokers{} may appear multiple times"
            -- "and have varied abilities"
            -- "Exactly one existing {C:attention}Horse Joker{}"
            -- "isn't {C:dark_edition}negative{} at all times"
        } do
            horse_ability_description[] = line

        local horse_name
        if index <= #horse_names
            horse_name = horse_names[index]
        else
            horse_name = "Unnamed Horse (#{index})"
        print("Added horse", index, bonus_types)

        jackstr = jack and "jack" or ""
        key = bonus_1 .. bonus_2 .. bonus_3 .. jackstr

        horse_joker = SMODS.Joker
            key: "hhj_horse_" .. key
            atlas: "atlas_horses"
            pos: atlas_horses_positions[key]
            rarity: "hhj_horse"  -- They're "stored" in the horse rarity for easier polling, and changed to common in set_ability. This is a workaround bc I don't want to implement something better
            cost: 1
            discovered: true,
            config: {
                is_horse: true
                key: key
                bonuses: bonuses_for_this_horse
                jack: jack
            },
            loc_txt: {
                name: horse_name,
                text: horse_ability_description
            },
            loc_vars: (info_queue, card) => 
                if bonuses_for_this_horse.luck > 0
                    info_queue[] = {
                        key: "horse_luck"
                        set: "Other"
                        vars: { G.GAME and G.GAME.probabilities.normal or 1 }
                    }
                    info_queue[] = G.P_TAGS.tag_hhj_horse_luck
                
                return vars: {
                    G.GAME and G.GAME.probabilities.normal or 1
                }
            set_ability: (card, initial, delay_sprites) =>
                card.rarity = 1 
                update_horse_negatives()
            add_to_deck: (card, from_defuff) =>
                if from_defuff
                    return
                update_horse_negatives()
            remove_from_deck: (card, from_defuff) =>
                if from_defuff
                    return
                update_horse_negatives()
            -- in_pool: (args) => false
            calculate: (card, context) =>
                horse = card.ability
                if (
                    -- Chips and mult are reset after "before" is finished, so they can't be added before then. It's because the hand can level up in that step
                    -- Could maybe implement a "after_before" step to address this?
                    -- Shouldn't be *that* hard, surely :]
                    
                    -- ((horse.jack == false) and context.before and context.cardarea == G.jokers) or
                    ((horse.jack == false) and context.joker_main and context.cardarea == G.jokers) or
                    ((horse.jack == true ) and context.individual and context.cardarea == G.play and context.other_card\get_id() == 11)
                ) then
                    money_earned = 0
                    for _ = 1, horse.bonuses.money
                        if pseudorandom('horse_money') < G.GAME.probabilities.normal / 2
                            money_earned += 1
                    
                    for _ = 1, horse.bonuses.luck
                        if pseudorandom('horse_luck') < G.GAME.probabilities.normal / 20
                            G.E_MANAGER::add_event(Event
                                func: () ->
                                    add_tag(Tag('tag_hhj_horse_luck'))
                                    play_sound('generic1', 0.9 + math.random()*0.1, 0.8)
                                    play_sound('holo1', 1.2 + math.random()*0.1, 0.4)
                                    neigh()
                                    return true
                            )
                            card_eval_status_text(card, 'extra', nil, nil, nil, {message: "HORSE LUCK", colour: G.C.GREEN})
                    
                    output = {
                        -- card: self,
                        chips: horse.bonuses.chips,
                        mult: horse.bonuses.mult,
                        dollars: money_earned,
                        -- func:
                        --     G.E_MANAGER\add_event(Event({
                        --         func: () -> 
                        --             card\juice_up(0.5, 0.5) if self.config.jack == true
                        --             return true
                        --     })) 
                    }
                    for key, value in pairs(output)
                        output[key] = value != 0 and value or nil
                    return output
            -- loc_vars: (info_queue, card) => 
            --     print(card)
            --     info_queue[] = {
            --             name: "Horse?"
            --             text: {"desc"}
            --     }


macro lua = (code) -> {
  :code
  type: "lua"
}

useful_things = assert(SMODS.load_file("useful_things.lua"))()
useful_things.wrap_method(Card, "hover", (...) ->
    self = ...
    neigh() if self.config.center?.config?.is_horse
)
    


-- $lua[==[
-- function horse_joker:hover()
--     wrapper()
-- end
-- ]==]

ref = Card.set_edition
wrapper = (self, edition, immediate, silent) -> 
    ref(self, edition, immediate, silent)

    -- print(self.config.center)
    -- print(self.config.center?.config)
    if self.config.center?.config?.is_horse != nil then
        horse_joker = self.config.center
        the_sprite_is_in_here = self.children.center
        -- print(the_sprite_is_in_here)
        -- print(edition)
        -- print(edition == "e_negative")
        local change_pos_to
        if (edition != nil and (edition == "e_negative" or edition.negative)) then
            change_pos_to = atlas_horses_positions[horse_joker.config.key .. "neg"]
            -- print() -- horse_joker.pos = atlas_horses_positions[horse_joker.config.key]
        else
            change_pos_to = atlas_horses_positions[horse_joker.config.key]
        -- print(atlas_horses_positions)
        -- print(horse_joker.config.key)
        -- print(change_pos_to)
        -- print(atlas_horses_positions[horse_joker.config.key])
        change_pos_to = atlas_horses_positions[horse_joker.config.key .. "neg"]
        if horse_joker.pos != change_pos_to then
            horse_joker.pos = change_pos_to
            -- print(the_sprite_is_in_here.sprite_pos)
            the_sprite_is_in_here\set_sprite_pos(horse_joker.pos)
            



-- the raw string leading and ending symbols are auto trimed
$lua[==[
function Card:set_edition(edition, immediate, silent)
    wrapper(self, edition, immediate, silent)
end
]==]

nil  -- can't end in a macro. https://github.com/IppClub/YueScript/issues/178