assert(SMODS.load_file("libs\\LuaNES\\main.lua"))()

-- self.nes = spawn_a_nes()
-- It takes about 207 frames to go all the way across the bottom, which spans 19 dots
-- so we want one rank to equal, what, half a dot? that seems about right?
frame_multiplier = math.floor(207 / 19 / 2)

keys = {
    UP: "w"
    LEFT: "a"
    DOWN: "s"
    RIGHT: "d"
    A: "o"
    B: "p"
    SELECT: "i"
    START: "return"
    NOTHING: "4"
}


class Input
    new: (key, frames) =>
        @key = key
        @frames = frames

pretend_youre_drawable = (drawable, and_do_this) ->
    prep_draw(drawable, 1)
    and_do_this()    
    love.graphics.pop()
    
pretend_youre_a_center = (center, and_do_this) ->
    if not center.states.visible then return
    if center.sprite_pos.x ~= center.sprite_pos_copy.x or center.sprite_pos.y ~= center.sprite_pos_copy.y
        center::set_sprite_pos(center.sprite_pos)
    prep_draw(center, 1)
    love.graphics.scale(1/(center.scale.x/center.VT.w), 1/(center.scale.y/center.VT.h))
    love.graphics.setColor(overlay or G.BRUTE_OVERLAY or G.C.WHITE)

    -- love.graphics.draw(
    --     card.atlas.image,
    --     card.center,
    --     0 ,0,
    --     0,
    --     card.VT.w/(card.T.w),
    --     card.VT.h/(card.T.h)
    -- )
    and_do_this()

    love.graphics.pop()
    add_to_drawhash(center)
    center::draw_boundingrect()
    if center.shader_tab then love.graphics.setShader()

field_replace_context = (object, field_name, value, do_this) ->
    original_value = object[field_name]  -- Does this instead of dividing it back bc of floating point inaccuracy
    object[field_name] = value
    do_this()
    object[field_name] = original_value
    -- print("#{object}.#{field_name} from #{original_value} to  #{value} and back to  #{original_value}")

field_operation_context = (object, field_name, operation, do_this) ->
    field_replace_context(object, field_name, operation(object[field_name]), do_this)

field_addition_context = (object, field_name, the_guy_you_add_idk, do_this) ->
    field_operation_context(object, field_name, ((x) -> x+the_guy_you_add_idk), do_this)

field_multiplication_context = (object, field_name, multiplier, do_this) ->
    field_operation_context(object, field_name, ((x) -> x*multiplier), do_this)

pac_man = SMODS.Joker
    key: "pac_man"
    atlas: "atlas_jokers"
    loc_txt:
        name: "Pac-Man"
        text: {
            "Play literally Pac-Man for the NES lmao"
            "Control it by scoring cards"
            "{s:0.8,C:inactive}Number cards hold the direction of their suit"
            "{s:0.8,C:inactive}for that number of frames (x#{frame_multiplier})"
            "{s:0.8,C:inactive}Faces and Aces just press their button"
            "{s:0.8,C:inactive}The game doesn't run when no input is given"
            "{C:chips}Score/Chips: #1#"
        }
    loc_vars: (info_queue, card) => 
        return vars: {
            card.ability.score
        }
    pos: atlas_jokers_positions["pac_man"]
    set_ability: (card, initial, delay_sprites) =>
        self.nes = spawn_a_nes()
        print("set :)")
        -- print("boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it boutta load it ")
        self.nes.load({"Mods\\balatro-unknown-mod\\libs\\LuaNES\\roms\\Pac-Man.nes"})
        self.nes.update() -- Update just once to spawn the image
        card.ability.inputs = {
            -- This is NOT an optimal set of inputs 
            Input(keys.START, 1),
            Input(keys.START, 1),
            Input(keys.START, 1),
            Input(keys.START, 1),
            Input(keys.START, 1),
            Input(keys.START, 1),
            Input(keys.START, 1),
            Input(keys.START, 1),
            Input(keys.NOTHING, 60),
            Input(keys.A, 1),
            Input(keys.START, 1),
            Input(keys.NOTHING, 60*4.5),
        }
        card.ability.score = 0
    draw: (card, layer) =>
        self.nes.update_image()
        -- if card.children.h_popup
        --     -- print([key for key, value in pairs(card.children.h_popup)])
        --     -- print([key for key, value in pairs(card.children.h_popup.T)])
        --     pac_man_container = card.children.h_popup::get_UIE_by_ID("pac_man_container")
        --     card.ability.screen_x = card.children.h_popup.T.x
        --     card.ability.screen_y = card.children.h_popup.T.y
        --     pretend_youre_drawable(pac_man_container, ->
        --         love.graphics.draw(self.nes.image, 0, 0)
        --     )
        
        center = card.children.center
        -- 71 is how wide, in pixels, cards are
        screen_dims = {
            x: 10
            y: 10
            w: 51
            h: 46
        }
        screen_size_multiplier_x = 256 / screen_dims.w  -- Dude for some reason making the scale bigger makes the screen smaller? WAK
        screen_size_multiplier_y = 240 / screen_dims.h
        multiply_your_pixels_by_this_for_movement = G.CARD_W / 71 -- How wide cards are in pixels vs how wide they are in the funny mystery units the game uses
        field_multiplication_context(center.scale, "x", screen_size_multiplier_x, ->
            field_multiplication_context(center.scale, "y", screen_size_multiplier_y, ->
                field_addition_context(center.VT, "x", (screen_dims.x-1) * multiply_your_pixels_by_this_for_movement, -> -- why is it off by 1? probably something to do with how it doesn't seem to fully respect the scale...
                    field_addition_context(center.VT, "y", (screen_dims.y) * multiply_your_pixels_by_this_for_movement, ->
                        pretend_youre_a_center(center, ->
                            love.graphics.draw(self.nes.image, 0, 0)
                        )
                    )
                )
            )
        )
        
        -- love.graphics.draw(self.nes.image, card.ability.screen_x, card.ability.screen_y)
    update: (card, dt) =>
        self::process_inputs(card)
        score = ""
        peek_ram = self.nes.get_actual_internal_nes_object().cpu::peek_ram
        for address = 0x0070, 0x0075
            score = tostring(peek_ram(address)) .. score
        score ..= "0"
        card.ability.score = tonumber(score)
    generate_ui: (info_queue, card, desc_nodes, specific_vars, full_UI_table) =>
        SMODS.Joker.generate_ui(self, info_queue, card, desc_nodes, specific_vars, full_UI_table)
        
        -- I took a reference screenshot with a somewhat arbitrarily sized red square in it
        -- IDK what the units in the UI *are* but we should be able to figure out what to tell it to get what number of pixels
        -- (We want a section for the game that's *always* the size of an NES screen)
        nes_width = self.nes.image::getWidth()
        nes_height = self.nes.image::getHeight()

        ref_sizes = {
            red:
                pixels:
                    w: 214
                    h: 200
                stated:
                    w: 240/100
                    h: 224/100
            window:
                pixels:
                    w: 2048
                    h: 1152
            nes:
                pixels:
                    w: nes_width
                    h: nes_height
        }
        red_stated_to_pixels_ratio = ref_sizes.red.pixels.w / ref_sizes.red.stated.w
        window_width, window_height = love.graphics.getDimensions()
        window_scale = math.min(
            window_width /  ref_sizes.window.pixels.w,
            window_height / ref_sizes.window.pixels.h,
        )
        request_this_size = {
            w: ref_sizes.red.stated.w * (ref_sizes.nes.pixels.w / ref_sizes.red.pixels.w) / window_scale
            h: ref_sizes.red.stated.h * (ref_sizes.nes.pixels.h / ref_sizes.red.pixels.h) / window_scale
        }

        if card.children.h_popup
            -- print([key for key, value in pairs(card.children.h_popup)])
            -- print([key for key, value in pairs(card.children.h_popup.T)])
            pac_man_container = card.children.h_popup::get_UIE_by_ID("pac_man_container")
            card.ability.screen_x = card.children.h_popup.T.x
            card.ability.screen_y = card.children.h_popup.T.y
            -- pretend_youre_drawable(pac_man_container, ->
            --     love.graphics.draw(self.nes.image, 0, 0)

        wait_can_i_just=Moveable()
        cardself = self
        -- wait_can_i_just.VT.scale = 71 / 256
        wait_can_i_just.draw = =>
            prep_draw(self, 1)
            screen_x, screen_y = love.graphics.transformPoint(0, 0)
            love.graphics.origin()
            pixel_x, pixel_y = love.graphics.inverseTransformPoint(math.floor(screen_x+0.5), math.floor(screen_y+0.5))

            -- left, top = love.graphics.transformPoint(0, 0)
            -- right, bottom = love.graphics.transformPoint(nes_width, nes_height)
            -- width = (right-left)
            -- height = (bottom-top)
            -- scale_x = 1/(width  / nes_width)
            -- scale_y = 1/(height / nes_height)
            -- love.graphics.scale(scale_x, scale_y)
            love.graphics.setColor(1, 1, 1)

            -- Measuring so that it can be offset just enough to line up with a perfect pixel
            -- This doesn't work though. Honestly very unsatisfying
            -- uuuhhhhh it's crt coded
            -- left_pixel, top_pixel = love.graphics.inverseTransformPoint(0, 0)
            -- right_pixel, bottom_pixel = love.graphics.inverseTransformPoint(1, 1)
            -- width =  ( right_pixel-left_pixel)
            -- height = (bottom_pixel- top_pixel)
            -- love.graphics.translate( width, height )

            love.graphics.draw(cardself.nes.image, pixel_x, pixel_y)
            love.graphics.pop()

        desc_nodes[] = {{
            n: G.UIT.C
            config: 
                id: "pac_man_container"
                minw: request_this_size.w
                minh: request_this_size.h
                --colour: G.C.RED 
            nodes: {
                {
                    n: G.UIT.O,
                    config: {
                        object: wait_can_i_just
                        --colour: G.C.WHITE
                    }
                }
            }
        }}
        --print(desc_nodes)
        --print(full_UI_table)
        -- print({
        --     minw: 240/100
        --     minh: 224/100
        --     window_width: window_width
        --     window_height: window_height
        --     red_stated_to_pixels_ratio: red_stated_to_pixels_ratio
        --     request_this_size: request_this_size
        --     window_scale: window_scale
        -- })
    calculate: (card, context) =>
        if context.joker_main and context.cardarea == G.jokers
            return {
                chips: card.ability.score
            }
        elseif context.individual and context.cardarea == G.play
            print("brhg")
            if context.other_card.ability.effect == 'Stone Card'
                return
            input_to_add = nil
            card_id = context.other_card::get_id()
            input_to_add = switch card_id
                when 14
                    Input(keys.A, 1)
                when 13
                    Input(keys.START, 1)
                when 12
                    Input(keys.SELECT, 1)
                when 11
                    Input(keys.B, 1)
                else
                    switch context.other_card.base.suit
                        when "Spades"
                            Input(keys.UP, card_id*frame_multiplier)
                        when "Hearts"
                            Input(keys.DOWN, card_id*frame_multiplier)
                        when "Diamonds"
                            Input(keys.LEFT, card_id*frame_multiplier)
                        when "Clubs"
                            Input(keys.RIGHT, card_id*frame_multiplier)
                        else
                            nil
            print(input_to_add)
            if input_to_add
                G.E_MANAGER::add_event(Event
                    func: ->
                        card.ability.inputs[] = input_to_add
                        true
                )
    
    process_inputs: (card) =>
        input = card.ability.inputs[1]
        if input
            if input.frames == 0
                self.nes.keyreleased(input.key)
                --print("release ", input.key)
                card.ability.inputs = [x for x in *card.ability.inputs[2,]]
                self::process_inputs(card)
            else
                self.nes.keypressed(input.key)
                --print("press ", input.key)
                input.frames -= 1
                self.nes.update()